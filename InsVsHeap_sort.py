# -*- coding: utf-8 -*-
"""sorting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Oshv42EJI-CNDMCFvu-929CnuCCQ_Bf6
"""

import time as t
import matplotlib.pyplot as plt
import numpy as np
import math


def Isort(array):
  size = len(array)
  for sorted_index in range(1, size):
        i = array[sorted_index]
        j = sorted_index
        while j > 0 and array[j - 1] > i:
            array[j] = array[j -1]
            j = j - 1
        array[j] = i

def heapsort(array):
  size = len(array)
  build_minheap(array, size)
  for i in range(size-1, 0, -1):
    temp = array[0]
    array[0] = array[i]
    array[i] = temp
    min_heapify(array, 0, i)

def build_minheap(array, n):
  for i in range(n//2 - 1, -1, -1):
    min_heapify(array, i, n)

def min_heapify(array, i, n):
  smallest = i
  l = 2*(i) + 1
  r = 2*(i) + 2
  if l < n and array[smallest] < array[l]:
    smallest = l
  if r < n and array[smallest] < array[r]:
    smallest = r
  if smallest != i:
    temp = array[i]
    array[i] = array[smallest]
    array[smallest] = temp
    min_heapify(array, smallest, n)

def Msort(array):
  size = len(array)
  if size > 1:
    mid = len(array)//2
    first_half = array[:mid]
    second_half = array[mid:]
    Msort(first_half)
    Msort(second_half)
    i = j = 0
    sorted_index = 0

    while (i < len(first_half)) and (j < len(second_half)) :
      if (first_half[i] < second_half[j]) :
        array[sorted_index] = first_half[i]
        i+=1
      else:
        array[sorted_index] = second_half[j]
        j+=1
      sorted_index += 1
    
    while (i < len(first_half)):
      array[sorted_index] = first_half[i]
      i+=1
      sorted_index += 1
    
    while (j < len(second_half)):
      array[sorted_index] = second_half[j]
      j+=1
      sorted_index += 1
    
def Sorter():
  M_times = []
  I_times = []
  H_times = []
  for i in range(1, 500):
    test_array_1 = np.random.randint(-999999, 999999,i)
    test_array_2 = test_array_1.copy()
    test_array_3 = test_array_1.copy()
    start_M = t.time()
    Msort(test_array_1)
    end_M = t.time() - start_M
    M_times.append(end_M)
    start_I = t.time()
    Isort(test_array_2)
    end_I = t.time() - start_I
    I_times.append(end_I)
    start_H = t.time()
    heapsort(test_array_3)
    end_H = t.time() - start_H
    H_times.append(end_H)

  # n0_list = list(map(lambda x, y, z : I_times.index(x) if (x < y) else -1, I_times, M_times, H_times))
  # print("Max n0 for this event " + str(max(n0_list)))
  plot1, = plt.plot(list(range(1, 500)),  M_times)
  plot2, = plt.plot(list(range(1, 500)),  I_times)
  plot3, = plt.plot(list(range(1, 500)),  H_times)
  plt.legend([plot1, plot2, plot3],["Merge sort", "Insertion sort", "Heap Sort"])
  plt.xlabel("size")
  plt.ylabel("time")
  plt.title("Sort times")
  plt.show()

Sorter()